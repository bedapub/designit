bind_cols(expand.grid(OrderWithin = 11:16, Plex = c("P1", "P2")))
) %>%
arrange(...1) %>%
select(-`10 POSSIBLE LABELS`)
plot_design(final, .color = Plex, `health status`, `EV isolation date`)
write_excel_csv(final, "sample_order.csv")
write_excel_csv(final %>% select(-...1), "sample_order.csv")
sign
a <- readxl::read_excel('/pstore/data/bioinfo/users/julienla/Project/RNAseqAnalysis/CEA-CIT/CEA-PRIT_CEAmodels_for randomization.xlsx')
summary(mtcars)
glance(mtcars)
dplyr::glimpse(mtcars)
?warning
irix
irs
iris
iris %>% summarize_all()
library(tidyverse)
iris
iris %>% summarize_all()
iris %>% summarize_all(~sum)
iris %>% summarize_all("mean")
iris %>% summarize_all(~recode(mean(.), .missing = "All"))
iris %>% summarize_all(~recode(mean(.), .default = ~as.character(.), .missing = "All"))
iris %>% summarize_all(~replace_na(mean(.), "All"))
iris %>% group_by(Species) %>% summarize_all(~replace_na(mean(.), "All"))
iris %>% group_by(Species) %>% summarize_all(~replace_na(mean(.), "All")) %>% ungroup() %>% summarize_all(~replace_na(mean(.), "All"))
iris %T>% group_by(Species) %>% summarize_all(~replace_na(mean(.), "All")) %T>% summarize_all(~replace_na(mean(.), "All"))
library(magrittr)
iris %T>% group_by(Species) %>% summarize_all(~replace_na(mean(.), "All")) %T>% summarize_all(~replace_na(mean(.), "All"))
?`%T>%`
funs <- funs(mean)
list(mean, median)
funs=list(mean, median)
mtcars
mtcars %>% group_by(gear, carb)
bind_rows(mtcars, mtcars %>% group_by(gear, carb))
mtcars %>% mutate_at(vars(cyl, gear, carb), "NA")
mtcars %>% mutate_at(vars(cyl, gear, carb), ~"NA")
mtcars %>% mutate_at(vars(cyl, gear, carb), ~"All")
for (i in vars(cyl, gear, carb)) mtcars %>% mutate_at(i, ~"All")
for (i in c(cyl, gear, carb)) mtcars %>% mutate_at(vars(i), ~"All")
for (i in c("cyl", "gear", "carb")) mtcars %>% mutate_at(vars(i), ~"All")
lapply(c("cyl", "gear", "carb"), function(i) mtcars %>% mutate_at(vars(i), ~"All"))
lapply(c("cyl", "gear", "carb"), function(i) mtcars %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
mtcars %>% mutate_at(vars(cyl, gear, carb), factor)
mtcars2 <- mtcars %>% mutate_at(vars(cyl, gear, carb), factor)
lapply(c("cyl", "gear", "carb"), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(c("cyl", "gear", "carb", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(c("cyl", "gear", "carb", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows() %>% tail()
lapply(c("cyl", "gear", "carb", list("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(c("cyl", "gear", "carb", list("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows() %>% tail()
mtcars %>% mutate_at(vars(cyl, gear, carb), ~"All")
lapply(c("cyl", "gear", "carb", list("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows() %>% tail()
lapply(c(list("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows() %>% tail()
lapply(c(list("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
mtcars %>% mutate_at(vars("cyl", "gear", "carb"), ~"All")
mtcars %>% mutate_at(vars(list("cyl", "gear", "carb")), ~"All")
mtcars %>% mutate_at(vars(c("cyl", "gear", "carb")), ~"All")
lapply(list(c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(list("cyl", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(list("cyl", "gear", "carb", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
lapply(list("cyl", "gear", "carb", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows() %>% tail()
mtcars3 <- lapply(list("cyl", "gear", "carb", c("cyl", "gear", "carb")), function(i) mtcars2 %>% mutate_at(vars(i), ~"All")) %>% bind_rows()
mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(mean)
mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(mean) %>% arrange(cyl, gear, carb)
mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(mean) %>% arrange(desc(cyl), desc(gear), desc(carb))
mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(mean)
mtmean <- mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(mean)
View(mtmean)
View(mtcars3)
View(mtmean)
mtsum <- mtcars3 %>% group_by(cyl, gear, carb) %>% summarize_all(sum)
View(mtsum)
devtools::install_dev_deps()
library(knitr)
library(openxlsx)
library(designit)
library(DesignIt)
install.packages(c('shinymeta', 'AlgDesign'))
install.packages('shinymeta')
installr::updateR()
install.packages('yaml')
install.packages('shinymeta')
install.packages('Rtools')
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
setwd("C:/Users/siebourj/work_offline/designit")
install.packages('ineq')
install.packages('AlgDesign')
install.packages('shinymeta')
devtools::install_git('shinymeta')
install.packages('devtools')
library(devtools)
install.packages('usethis')
library(devtools)
library(devtools)
install.packages('fs')
library(devtools)
install.packages('fansi')
library(devtools)
install.packages('elipsis')
install.packages('ellipsis')
update.packages()
BiocManager::install(version = "3.11")
BiocManager::install(version = "3.11", checkBuilt = TRUE)
library(devtools)
devtools::install_github('shinymeta')
devtools::install_github('RStudio/shinymeta')
install.packages('glue')
install.packages('glue')
devtools::install_github('RStudio/shinymeta')
library(designit)
samples <- read.xlsx('HTRA1 cyno PKPK EX16_499828.xlsx',
check.names = TRUE)
setwd("O:/OPH/70079_HTRA1_LNA_wAMD/HTRA1_CynoStudy_pkpd/msAssey_design")
samples <- read.xlsx('HTRA1 cyno PKPK EX16_499828.xlsx',
check.names = TRUE)
list.files()
samples <- read.xlsx('HTRA1 cyno PKPK EX16_499828.xlsx',
check.names = TRUE)
samples <- openxlsx::read.xlsx('HTRA1 cyno PKPK EX16_499828.xlsx',
check.names = TRUE)
kable(samples)
library(knitr)
library(openxlsx)
library(DesignIt)
library(tidyverse)
kable(samples)
s2 <- samples
s2$animals <- 1
samples <- data.table(rbind(s2,samples))
setnames(samples,'animals','animal')
samples <- rbindlist(list(samples,samples,samples))
samples$replicate <- rep(1:3, each = 10)
s2,samples
s2
samples
samples <- bind_rows(s2,samples))
samples <- bind_rows(s2,samples)
s2 <- samples
s2$animals <- 1
samples <- bind_rows(s2,samples) %>%
rename(animal = animals)
samples <- bind_rows(list(samples,samples,samples))
samples <- samples %>%
mutate(replicate = rep(1:3, each = 10),
SampleID = paste0(Treatment,'_',animal,'_',replicate),
AnimalID = paste0(Treatment,'_',animal))
samples <- openxlsx::read.xlsx('HTRA1 cyno PKPK EX16_499828.xlsx',
check.names = TRUE)
kable(samples)
s2 <- samples
s2$animals <- 1
samples <- bind_rows(s2,samples) %>%
rename(animal = animals)
samples <- bind_rows(list(samples,samples,samples))
samples <- samples %>%
mutate(replicate = rep(1:3, each = 10),
SampleID = paste0(Treatment,'_',animal,'_',replicate),
AnimalID = paste0(Treatment,'_',animal))
nloc <- 8*4 # available locations
nsamp <- nrow(samples)   # number of samples
empty <- nloc - nsamp
emptydf <- data.frame(matrix(NA,nrow = empty,ncol = ncol(samples)))
colnames(emptydf) <- colnames(samples)
emptydf$Treatment <- 'empty'
emptydf$FixColumn <- 4
emptydf$FixRow <- 8 + 1 - (1:empty)
design <- full_join(samples, emptydf, by = intersect(colnames(samples), colnames(emptydf)))
samples
emptydf
str(samples)
str(empty)
str(emptydf)
nloc
emptydf <- data.frame(Treatment <- 'empty',
FixColumn <- 4,
FixRow <- 8 + 1 - (1:empty))
design <- full_join(samples, emptydf, by = intersect(colnames(samples), colnames(emptydf)))
design <- full_join(samples, emptydf)
head(samples)
head(emptydf)
emptydf <- data.frame(Treatment = 'empty',
FixColumn = 4,
FixRow = 8 + 1 - (1:empty))
design <- full_join(samples, emptydf)
design
### experimental settings
resultname <- "test_design"
layoutDim <- c(Row = 8, Column = 4)
scoringGroups <- list(c('Row'),c('Column'))
scoringTests <- list('countGini','countGini')
scoringWeights <- c(Row = 1, Column = 2)
balance <- c('AnimalID')
balweights <- c(1,1);
names(balweights) <- balance
report <- "SampleID" # column with a unique ID
#annealprotocol <- rep(c(10,5,2,1), c(500,1000,2000,5000))
annealprotocol <- rep(c(10,5,2,1), c(50,150,300,300))
### run randomization
results<-randomize(design, report, layoutDim, balance,
#testing
scoringGroups = scoringGroups,
scoringTests = scoringTests,
#anneling params
burnin=500,
annealprotocol = annealprotocol,
#weights
scoringWeights = scoringWeights,
balweights = balweights,
# initial distribution
distribute = 1:(prod(layoutDim)))
library(designit)
save(results, file=paste0(resultname, '.RData'))
save(results, file=paste0(resultname, '.RData'))
### run randomization
results<-randomize(design, report, layoutDim, balance,
#testing
scoringGroups = scoringGroups,
scoringTests = scoringTests,
#anneling params
burnin=500,
annealprotocol = annealprotocol,
#weights
scoringWeights = scoringWeights,
balweights = balweights,
# initial distribution
distribute = 1:(prod(layoutDim)))
designit::plot_design()
designit::plot_design(design)
designit::plot_design(layout)
designit::plot_design(design)
library(designit)
library(designit)
devtools::load_all("C:/Users/siebourj/work_offline/designit")
### run randomization
results<-randomize(design, report, layoutDim, balance,
#testing
scoringGroups = scoringGroups,
scoringTests = scoringTests,
#anneling params
burnin=500,
annealprotocol = annealprotocol,
#weights
scoringWeights = scoringWeights,
balweights = balweights,
# initial distribution
distribute = 1:(prod(layoutDim)))
prod(layoutDim)
nloc
grid <- expand.grid(sapply(layoutDim,
function(x){seq(1 ,x)}, simplify = F)) # TODO: maybe lapply?
grid
grid <- expand.grid(sapply(layoutDim, function(x){seq(1 ,x)}, simplify = F)) %>% # TODO: maybe lapply?
as.data.frame()
grid
shuffle <- rep.int(0, nloc) # vectors to track fixed fixedPos
fixed <- rep(FALSE, nloc)
# # make factors
#for (f in balance) {design[,f] = factor(design[,f])}
design <- design %>%
dplyr::mutate_at(.vars = vars(balance), factor)
design
str(design)
balance
# Adding empty samples
if (nloc < nsamp) {stop('too many samples')
} else if (nloc > nsamp) {
nempty <- nloc - nsamp
cat('\n Adding', nempty,'empty sample(s) to fill layout\n')
design[(nsamp + 1):nloc, ] <- matrix(NA, ncol = ncol(design), nrow = nempty)
}
design
# get fixed position columns
fixedPos <- design[, grep('Fix', colnames(design))]
length(fixedPos)
recode_factor()
a <- c('a', 'b', 'c')
mapvalues(v, from =letters[1:3], to = 1:3)
plyr::mapvalues(v, from =letters[1:3], to = 1:3)
plyr::mapvalues(a, from =letters[1:3], to = 1:3)
plyr::mapvalues(1:3, from =1:3, to = letters[1:3])
plyr::mapvalues(1:3, from =1:3, to = letters[1:3]) %>% str()
devtools::load_all("C:/Users/siebourj/work_offline/designit")
library(designit)
library(designit)
grid
design[shuffle, ]
# Adding empty samples
if (nloc < nsamp) {stop('too many samples')
} else if (nloc > nsamp) {
nempty <- nloc - nsamp
cat('\n Adding', nempty,'empty sample(s) to fill layout\n')
design[(nsamp + 1):nloc, ] <- matrix(NA, ncol = ncol(design), nrow = nempty)
}
# get fixed position columns
fixedPos <- design[, grep('Fix', colnames(design))]
if (length(fixedPos) > 0) {
# convert to numeric
convert <- colnames(fixedPos)[sapply(fixedPos, is.character)]
if (length(convert) > 0) {
fixedPos[, convert] <- lapply(
convert, function(col){dim <- sub('Fix','',col);
fixedPos[, col] <- toupper(fixedPos[, col]);
fixedPos[, col] <- factor(fixedPos[, col], labels = 1:layoutDim[dim]);
as.numeric(fixedPos[, col])})
}
# put columns in same order as layoutDim
fixedPos <- fixedPos[, paste0('Fix', names(layoutDim))]
# fixed position index vector
if (ncol(fixedPos) == length(layoutDim)) {
# fixed position indicator
f <- apply((!is.na(fixedPos)), 1, all)
# fixed vector index
idxf <- apply(fixedPos[which(f), 1:ndim], 1,
function(pos){sum((pos - c(0, rep(1, ndim - 1))) *
cumprod(c(1, layoutDim[1:(ndim - 1)])))})
fixed[idxf] <- TRUE
shuffle[idxf] <- (1:nloc)[f]
if (length(distribute) == length(f)) {
distribute <- distribute[!f]
}
}
# TODO: add something for reusable layout, i.e. same fixed rows / cols per each plate
}
# initialization
nloc <- prod(layoutDim) # available locations
nsamp <- nrow(design)   # number of samples
ndim <- length(layoutDim) # number of experiment dimensions
grid <- expand.grid(sapply(layoutDim, function(x){seq(1 ,x)}, simplify = F)) %>% # TODO: maybe lapply?
as.data.frame()
shuffle <- rep.int(0, nloc) # vectors to track fixed fixedPos
fixed <- rep(FALSE, nloc)
# make factors
design <- design %>%
dplyr::mutate_at(.vars = vars(balance), factor)
# Adding empty samples
if (nloc < nsamp) {stop('too many samples')
} else if (nloc > nsamp) {
nempty <- nloc - nsamp
cat('\n Adding', nempty,'empty sample(s) to fill layout\n')
design[(nsamp + 1):nloc, ] <- matrix(NA, ncol = ncol(design), nrow = nempty)
}
# get fixed position columns
fixedPos <- design[, grep('Fix', colnames(design))]
if (length(fixedPos) > 0) {
# convert to numeric
convert <- colnames(fixedPos)[sapply(fixedPos, is.character)]
if (length(convert) > 0) {
fixedPos[, convert] <- lapply(
convert, function(col){dim <- sub('Fix','',col);
fixedPos[, col] <- toupper(fixedPos[, col]);
fixedPos[, col] <- factor(fixedPos[, col], labels = 1:layoutDim[dim]);
as.numeric(fixedPos[, col])})
}
# put columns in same order as layoutDim
fixedPos <- fixedPos[, paste0('Fix', names(layoutDim))]
# fixed position index vector
if (ncol(fixedPos) == length(layoutDim)) {
# fixed position indicator
f <- apply((!is.na(fixedPos)), 1, all)
# fixed vector index
idxf <- apply(fixedPos[which(f), 1:ndim], 1,
function(pos){sum((pos - c(0, rep(1, ndim - 1))) *
cumprod(c(1, layoutDim[1:(ndim - 1)])))})
fixed[idxf] <- TRUE
shuffle[idxf] <- (1:nloc)[f]
if (length(distribute) == length(f)) {
distribute <- distribute[!f]
}
}
# TODO: add something for reusable layout, i.e. same fixed rows / cols per each plate
}
distribute = 1:(prod(layoutDim))
if (length(fixedPos) > 0) {
# convert to numeric
convert <- colnames(fixedPos)[sapply(fixedPos, is.character)]
if (length(convert) > 0) {
fixedPos[, convert] <- lapply(
convert, function(col){dim <- sub('Fix','',col);
fixedPos[, col] <- toupper(fixedPos[, col]);
fixedPos[, col] <- factor(fixedPos[, col], labels = 1:layoutDim[dim]);
as.numeric(fixedPos[, col])})
}
# put columns in same order as layoutDim
fixedPos <- fixedPos[, paste0('Fix', names(layoutDim))]
# fixed position index vector
if (ncol(fixedPos) == length(layoutDim)) {
# fixed position indicator
f <- apply((!is.na(fixedPos)), 1, all)
# fixed vector index
idxf <- apply(fixedPos[which(f), 1:ndim], 1,
function(pos){sum((pos - c(0, rep(1, ndim - 1))) *
cumprod(c(1, layoutDim[1:(ndim - 1)])))})
fixed[idxf] <- TRUE
shuffle[idxf] <- (1:nloc)[f]
if (length(distribute) == length(f)) {
distribute <- distribute[!f]
}
}
# TODO: add something for reusable layout, i.e. same fixed rows / cols per each plate
}
optiX <- optiY <- vector() # vectors to track optimization
shuffle[!fixed] <- distribute #update shuffle vector
bestdist <- distribute
bestsol <- shuffle
# sort balance factors by current layout and get penalty score
mfac <- cbind(grid,design[shuffle, ])
mfac
globalmin <- getScore(layout = mfac, bal = balance, sc_groups = scoringGroups,
sc_tests = scoringTests, bal_weights = balweights,
sc_weights = scoringWeights)
str(mfac)
layout = mfac
bal = balance
sc_groups = scoringGroups
sc_tests = scoringTests
bal_weights = balweights
sc_weights = scoringWeights
scoresDim <- c() # vector to store the score of each dimension group
for (s in 1:length(sc_groups)) {
tscore <- 0
group <- sc_groups[[s]]
tests <- sc_tests[[s]]
for (ti in 1:length(tests)) {
# make test function from given string
testFun <- function(x){do.call(tests[[ti]], list(x))}
if (tests[[ti]] != 'meanDiff') {
# get the penalty for each dimension group
# factor von balace variables
penalty <- layout[, lapply(.SD, testFun), .SDcols = bal, by = group]
score <- penalty[, lapply(.SD, function(x){sum(x^2, na.rm = TRUE)}), .SDcols = bal]
score <- sum(score * bal_weights) #multiply score for each balance factor by its weight and sum
tscore <- tscore + score
} else {
# loop over balance variables
means <- layout[, lapply(.SD, mean), .SDcols = bal, by = group]
#uselevel <- ifelse(length(groups)>1, group[2])
diff <- means[, lapply(.SD, meanDiff), .SDcols = bal]
score <- sum(diff * bal_weights) #multiply score for each balance factor by its weight and sum
tscore <- tscore + score
}
}
scoresDim <- c(scoresDim, tscore)
}
# make test function from given string
testFun <- function(x){do.call(tests[[ti]], list(x))}
tests[[ti]] != 'meanDiff'
layout
penalty
group
layout %>% group_by(group)
# get the penalty for each dimension group
# factor von balace variables
layout %>% group_by(!!group)
# get the penalty for each dimension group
# factor von balace variables
layout %>% group_by(!!sym(group))
bal
# get the penalty for each dimension group
# factor von balace variables
layout %>% group_by(!!sym(group)) %>%
summarize(penalty = testFun(bal))
penalty <- layout[, lapply(data.table::.SD, testFun), data.table::.SDcols = bal, by = group]
data.table::.SDcols
#score <- penalty[, lapply(.SD, function(x){sum(x^2, na.rm = TRUE)}), .SDcols = bal]
score <- penalty %>%
summarize(score = sum(bal^2, na.rm = TRUE))
# get the penalty for each dimension group
# factor von balace variables
#penalty <- layout[, lapply(.SD, testFun), .SDcols = bal, by = group]
penalty <- layout %>% group_by(!!sym(group)) %>%
summarize_at(.vars = vars(bal), testFun)
penalty
#score <- penalty[, lapply(.SD, function(x){sum(x^2, na.rm = TRUE)}), .SDcols = bal]
score <- penalty %>%
summarize(score = sum(bal^2, na.rm = TRUE))
#score <- penalty[, lapply(.SD, function(x){sum(x^2, na.rm = TRUE)}), .SDcols = bal]
score <- penalty %>%
summarize(score = sum(!!sym(bal)^2, na.rm = TRUE))
#score <- penalty[, lapply(.SD, function(x){sum(x^2, na.rm = TRUE)}), .SDcols = bal]
score <- penalty %>%
summarize(score = sum((!!sym(bal))^2, na.rm = TRUE))
score <- sum(score * bal_weights) #multiply score for each balance factor by its weight and sum
tscore <- tscore + score
#uselevel <- ifelse(length(groups)>1, group[2])
diff <- means %>% summarize(.vars = vars(bal), meanDiff)
# loop over balance variables
#means <- layout[, lapply(.SD, mean), .SDcols = bal, by = group]
means <- layout %>%
summarize_at(.vars = vars(bal), .funs = mean)
library(designit)
library(designit)
install.packages('stylr')
install.packages('styler')
install.packages("styler")
styler:::style_active_file()
styler:::style_active_file()
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
library(designit)
setwd("C:/Users/siebourj/work_offline/designit/R")
devtools::document
devtools::document()
setwd("C:/Users/siebourj/work_offline/designit")
devtools::document()
