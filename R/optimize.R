

#' Extract relevant parameters from a generic shuffle function output
#'
#' Any shuffling function should return one of the following:
#' 1. atomic index vector for a direct location assignment
#' 2. a list with src and dst vector
#' 3. a list with locations vector (for location assignment) and optional sample_attr data frame/tibble
#'
#' This function parses the output, performs a few checks and returns results in a simple-to-use list.
#'
#' @param shuffle Return value of a shuffle function
#' @param attributes_expected Logical; if TRUE, sample attributes are expected from the shuffling result and the
#' function dies if they are not provided.
#'
#' @return A list with components src, dst, location_assignment and samples_attr, depending on the output
#' of the specific shuffling function
#' @keywords internal
extract_shuffle_params <- function(shuffle, attributes_expected) {

  # Extracts relevant parameters from shuffle function output and monitors correctness/consistency
  # Tried to avoid redundant checks that are performed on batch container level

  if (is.null(shuffle)) { # marks end of iteration schedule
    return(NULL)
  }

  if (rlang::is_atomic(shuffle)) {
    loc <- shuffle
    src <- dst <- attrib <- NULL
    assertthat::assert_that(!attributes_expected,
                            msg = "sample attributes must be consistently supplied by shuffle function once started"
    )
  } else {
    assertthat::assert_that(is.list(shuffle), msg = "shuffle proposal function must return either a numeric vector or a list")
    if (!is.null(shuffle[["src"]]) && !is.null(shuffle[["dst"]])) {
      loc <- NULL
      src <- shuffle[["src"]]
      dst <- shuffle[["dst"]]
    } else {
      assertthat::assert_that(!is.null(shuffle[["location_assignment"]]), msg = "shuffle function must return either a src/dst pair or a location vector")
      loc <- shuffle[["location_assignment"]]
      src <- dst <- NULL
    }
    if (is.null(shuffle[["samples_attr"]])) {
      assertthat::assert_that(!attributes_expected,
                              msg = "sample attributes must be consistently supplied by shuffle function once started"
      )
      attrib <- NULL
    } else {
      attrib <- shuffle[["samples_attr"]]
    }
  }

  list(src = src, dst = dst, location_assignment = loc, samples_attr = attrib)
}


#' Updates a batch container by permuting samples according to a shuffling
#'
#' As post-condition, the batch container is in a different state
#'
#' @param bc The batch container to operate on.
#' @param shuffle_params Shuffling parameters as returned by [extract_shuffle_params()].
#'
#' @return TRUE if sample attributes have been assigned, FALSE otherwise
#'
#' @keywords internal
update_batchcontainer <- function(bc, shuffle_params) {

    bc$move_samples(src = shuffle_params$src, dst = shuffle_params$dst,
                  location_assignment = shuffle_params$location_assignment)

  # Add sample attributes to container if necessary
  if (!is.null(shuffle_params[["samples_attr"]])) {
    bc$samples_attr <- shuffle_params[["samples_attr"]]
    TRUE
  } else {
    FALSE
  }
}



#' Generic optimizer that can be customized by user provided functions for generating shuffles and progressing towards the minimal score
#'
#' @param batch_container An instance of `BatchContainer`.
#' @param samples A `data.frame` with sample information.
#' Should be `NULL` if the `BatchContainer` already has samples in it.
#' @param n_shuffle Vector of length 1 or larger, defining how many random sample
#' swaps should be performed in each iteration. If length(n_shuffle)==1,
#' this sets no limit to the number of iterations. Otherwise, the optimization
#' stops if the swapping protocol is exhausted.
#' @param shuffle_proposal_func A user defined function to propose the next shuffling of samples.
#' Takes priority over n_shuffle if both are provided. The function is called with
#' a [BatchContainer] `bc` and an integer parameter `iteration` for the current iteration number,
#' allowing very flexible shuffling strategies.
#' The returned function must either return a list with fields `src`and `dst` (for pairwise sample swapping)
#' or a numeric vector with a complete re-assigned sample order.
#' @param acceptance_func Alternative function to select a new score as the best one.
#' Defaults to simply taking the overall best score. Max be replaced with an
#' acceptance function generated by mk_simanneal_acceptance_func() or a user provided function.
#' @param aggregate_scores_func A function to aggregate the scores.
#' By default the worst (i.e. highest) score will determine the aggregated value.
#' @param check_score_variance Logical: if TRUE, scores will be checked for variability under sample permutation
#' and the optimization is not performed if at least one subscore appears to have a zero variance.
#' @param autoscale_scores Logical: if TRUE, perform a transformation on the fly to equally scale scores
#' to a standard normal. This makes scores more directly comparable and easier to aggregate.
#' @param autoscaling_permutations How many random sample permutations should be done to estimate autoscaling parameters.
#' (Note: minimum will be 20, regardless of the specified value)
#' @param autoscale_useboxcox Logical; if TRUE, use a boxcox transformation for the autoscaling if possible at all.
#' Requires installation of the `bestNormalize` package.
#' @param sample_attributes_fixed Logical; if TRUE, sample shuffle function may generate altered sample attributes at each iteration.
#' This affects estimation of score distributions. (Parameter only relevant if shuffle function does introduce attributes!)
#' @param max_iter Stop optimization after a maximum number of iterations,
#' independent from other stopping criteria (user defined shuffle proposal or min_score)
#' @param min_score If not NA, optimization is stopped as soon as min_score or lower values are reached
#' @param quiet If TRUE, suppress non-critical warnings or messages.
#'
#' @return A trace object
#'
#' @export
optimize_design <- function(batch_container, samples = NULL, n_shuffle = NULL,
                            shuffle_proposal_func = NULL,
                            acceptance_func = accept_best_solution,
                            aggregate_scores_func = NULL,
                            check_score_variance = TRUE,
                            autoscale_scores = FALSE, autoscaling_permutations = 100, autoscale_useboxcox = TRUE,
                            sample_attributes_fixed = FALSE,
                            max_iter = 1e4, min_score = NA, quiet = FALSE) {
  start_time <- Sys.time()

  # based on https://stat.ethz.ch/pipermail/r-help/2007-September/141717.html
  if (!exists(".Random.seed")) stats::runif(1)
  save_random_seed <- .Random.seed

  if (is.null(samples)) {
    assertthat::assert_that(batch_container$has_samples,
                            msg = "batch-container is empty and no samples provided"
    )
  } else {
    assertthat::assert_that(nrow(samples) > 0)
    assign_in_order(batch_container, samples)
  }


  # Check presence of scoring function and that it's a list of functions
  assertthat::assert_that(!is.null(batch_container$scoring_f), msg = "no scoring function set for BatchContainer")
  assertthat::assert_that(is.list(batch_container$scoring_f), msg = "scoring function is expected to be a list")
  assertthat::assert_that(all(purrr::map_lgl(batch_container$scoring_f, is.function)), msg = "All scoring functions have to be function definitions")


  # Get assigned samples and locations from the batch container
  samp <- batch_container$get_samples(include_id = TRUE, assignment = TRUE, remove_empty_locations = FALSE)
  n_samples <- length(stats::na.exclude(samp$.sample_id))
  n_locations <- nrow(samp)

  assertthat::assert_that(".sample_id" %in% colnames(samp),
                          all(sort(samp$.sample_id, na.last = NA) == 1:n_samples),
                          msg = stringr::str_c(".sample_id from batch container must exist and numerate samples from 1 to ", n_samples)
  )

  assertthat::assert_that(is.null(n_shuffle) ||
                            (all(rlang::is_integerish(n_shuffle, finite = TRUE)) && all(n_shuffle >= 1)),
                          msg = "n_shuffle should be an integer or an integer vector (>=1), or NULL"
  )


  # Create shuffle_proposal_func
  # If passed by the user, this one getting priority over n_shuffle.
  # If nothing is passed, default shuffling function is to swap 2 random elements per iteration, which
  # is implemented by an especially efficient function.
  if (is.null(n_shuffle) && is.null(shuffle_proposal_func)) {
    shuffle_proposal_func <- mk_swapping_function(n_swaps = 1)
  } else if (is.null(shuffle_proposal_func)) {
    shuffle_proposal_func <- mk_swapping_function(n_swaps = n_shuffle)
    if (length(n_shuffle) > 1) {
      # Restrict number if iters, so that also trace object will be appropriately sized
      max_iter <- min(max_iter, length(n_shuffle), na.rm = T)
    }
  }

  assertthat::assert_that(is.function(shuffle_proposal_func), msg = "shuffle_proposal_func should be a function")


  # Do first iteration outside of loop; helps to perform initial checks just once
  iteration <- 1
  using_attributes <- FALSE # keeps track if attributes had been used in 1st iteration, since they must be provided consistently

  shuffle_params <- shuffle_proposal_func(batch_container, iteration) %>%
    extract_shuffle_params(attributes_expected = FALSE)

  # Always perform first shuffling before scoring the bc; works also if attributes are added at this stage
  # Otherwise remember initial state as currently best shuffling
  if (!is.null(shuffle_params[["samples_attr"]])) {
    if (!quiet) message("Usage of sample attributes --> executing first shuffling call.")
    update_batchcontainer(batch_container, shuffle_params)
    best_shuffle <- shuffle_params
  } else {
    best_shuffle <- list(src = NULL, dst = NULL, location_assignment = batch_container$assignment, samples_attr = NULL)
  }

  initial_score <- batch_container$score() # Evaluate this just once in order not to break current tests
  score_dim <- length(initial_score)

  assertthat::assert_that(score_dim==1 || !missing(aggregate_scores_func),
                          msg=stringr::str_c("Aggregation function has to be specific explicitly if a ", score_dim,
                                             "-dim. score is used.\nSee param 'aggregate_scores_func'."))

  # Check score variances (should be all >0)
  if (check_score_variance) {
    bc_copy = batch_container$copy()
    # Remove defensive checks later if possible
    assertthat::assert_that(identical(batch_container$get_samples(), bc_copy$get_samples()))
    assertthat::assert_that(identical(batch_container$assignment, bc_copy$assignment))
    score_vars = random_score_variances(batch_container$copy(), random_perm = 100, sample_attributes_fixed)
    low_var_scores = score_vars<1e-10
    if (!quiet) {
      message("Checking variances of ", length(low_var_scores), "-dim. score vector.",
              "\n... (",stringr::str_c(round(score_vars,3), collapse=", "), ")",
              ifelse(any(low_var_scores), " !!", " - OK"))
    }
    ne_scores = assertthat::validate_that(!any(is.na(low_var_scores)),
                            msg=stringr::str_c("Caution! Non-evaluable scores detected! Check scores # ",
                                               stringr::str_c(which(is.na(low_var_scores)), collapse=", ")))
    if (is.character(ne_scores)) message(ne_scores)
    assertthat::assert_that(!any(low_var_scores),
                            msg=stringr::str_c("Low variance scores detected! Check scores # ",
                                               stringr::str_c(which(low_var_scores), collapse=", ")))
  }


  # Set up autoscaling function if needed
  if (autoscale_scores && score_dim>1) {
    autoscaling_permutations = max(20, floor(autoscaling_permutations))
    if (!quiet) message("Creating autoscaling function for ", score_dim, "-dim. score vector. (",
                        autoscaling_permutations, " random permutations)")
    autoscale_func = mk_autoscale_function(batch_container$copy(),
                                           random_perm = autoscaling_permutations,
                                           use_boxcox = autoscale_useboxcox,
                                           sample_attributes_fixed)
  } else {
    autoscale_func = identity
  }

  # Calculate and remember initial multi-variate & aggregated score
  best_score <- autoscale_func(initial_score)
  best_agg <- aggregate_scores_func(best_score)


  trace <- OptimizationTrace$new(
    max_iter + 1, # + 1 to accommodate initial score
    length(batch_container$scoring_f),
    names(batch_container$scoring_f)
  )

  trace$set_scores(1, best_score, best_agg)

  if (!quiet) {
    message(
      "Initial aggregated score: ", best_agg, " (", score_dim, "-dim)",
      ifelse(score_dim < 2, "", stringr::str_c(" [c(", stringr::str_c(round(best_score, 3), collapse = ", "), ")]"))
    )
  }


  while (!is.null(shuffle_params) && (iteration <= max_iter)) { # NULL may indicate end of permutation protocol

    attribs_assigned = update_batchcontainer(batch_container, shuffle_params)
    if (!using_attributes && attribs_assigned) {
      message("Adding ", ncol(shuffle_params[["samples_attr"]]), " attributes to samples.")
      using_attributes <- TRUE
    }

    new_score <- autoscale_func(batch_container$score())
    assertthat::assert_that(!any(is.na(new_score)), msg = stringr::str_c("NA apprearing during scoring in iteration ", iteration))

    if (acceptance_func(aggregate_scores_func(new_score), best_agg, iteration)) {
      best_score <- new_score
      best_agg <- aggregate_scores_func(best_score)
      best_shuffle <- list(src = NULL, dst = NULL, location_assignment = batch_container$assignment,
                           samples_attr = shuffle_params[["samples_attr"]])
      if (!quiet) {
        message(
          "Achieved score: ", best_agg,
          ifelse(score_dim < 2, "", stringr::str_c(" [c(", stringr::str_c(round(best_score, 3), collapse = ", "), ")]")),
          " in iter ", iteration
        )
      }
    } else {
      if (is.null(shuffle_params[["location_assignment"]])) { # we used the permutation method and thus have to swap samples back!
        update_batchcontainer(batch_container, shuffle_params) # two swaps are in effect no swaps
      }
    }

    iteration <- iteration + 1
    trace$set_scores(iteration, best_score, best_agg)

    # Test stopping criteria
    if (!is.na(min_score) && best_agg <= min_score) {
      if (!quiet) {
        message("Reached min_score in ", iteration - 1, " iterations.")
      }
      break
    }

    if (iteration <= max_iter) {
      # only call shuffle_proposal_func in case we have more iterations
      shuffle_params <- shuffle_proposal_func(batch_container, iteration) %>%
        extract_shuffle_params(attributes_expected = using_attributes)
    }
  }

  # In the end, always make sure that final state of bc is the one with the best score
  update_batchcontainer(batch_container, best_shuffle)

  trace$shrink(iteration)
  trace$seed <- save_random_seed
  trace$elapsed <- Sys.time() - start_time
  trace
}
